\chapter{Current and expected problems}

\section{Expected Problems}

\subsection{Read speed over PCIe}

The current data reading speed offered over PCIe by the test setup is around 10MB/s which is more than enough required by the debugging
interface of AJIT processor which is around 40 KB/s. But this is considerably less when compared to the write speed offered over the same
bus which is around 400 MB/s. This could be a bottleneck in the future if we higher speeds are required over the debug interface of AJIT
processor.

\section{Addressed Problems}

\subsection{Motherboard memory space limit for PCIe bars}

The first approach in an attempt to interface the full range of on-board DRAM i.e. 4GB to the host machine was made in a straight forward
fashion by keeping a single bar of size 4GB the PCIe interface and it was expected that then by memory mapping by the thus generated
\verb|/sys/resourceX| files(where \verb|X| is an integer) generated by the PCIe-AXI IP would give the whole access to whole DRAM. But even
on repeated attempts of successful hardware designs we could not make the PCIe interface to generate a resource file of size 4GB. At first
this was suspected as an operating system issue but after further digging we found that the usual devices on PCIe bus of this machine had
memory regions of the scale 16MB, 32MB going as far as 64MB. Hence we brought down our bar sizes to 128MB after some trial and error we
found by experimentation that the motherboard had a limit on the BAR sizes of 128MB.We tried multiple BARS of smaller size i.e. 4K, 32MB etc
until we arrived at 128MB limit. This happened out of necessity and lack of open documentation over the internet. For example on two
different systems in EE department in IIT Bombay we found first machine's motherboard has a limit of 128MB bar size whereas another machine
has a limit of 256MB bar size. This makes the whole FPGA design scalable in terms of memory size and we can have the access to the whole 4GB
memory on a recent versioned motherboard.

\subsubsection{Vivado's random errors and resolving it by redundant actions}
Updation command offered by Vivado when run on project sources messes up sometimes to update the rebuilt custom IPs and shows that those IPs
have been locked and sometimes not found. This is mostly solved by checking permissions for the IP files or by repackaging the custom IPs or
by reloading the whole project.
